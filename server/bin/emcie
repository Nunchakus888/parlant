#!/usr/bin/python3

import asyncio
from dataclasses import dataclass
import os
from typing import Any
from urllib.parse import urljoin
import click
import click.shell_completion
import click_completion
import requests
import rich
from rich.text import Text
from tabulate import tabulate
from textwrap import wrap

from emcie.server.core.sessions import Event


async def main() -> None:
    click_completion.init()

    @dataclass(frozen=True)
    class Config:
        server_address: str

    @click.group
    @click.option(
        "-s", "--server", type=str, help="Server address", metavar="ADDRESS[:PORT]", required=True
    )
    @click.pass_context
    def cli(ctx: click.Context, server: str) -> None:
        if not ctx.obj:
            ctx.obj = Config(server_address=server)

    @cli.command(help="Generate shell completion code")
    @click.option("-s", "--shell", type=str, help="Shell program (bash, zsh, etc.)", required=True)
    def complete(shell: str) -> None:
        click.echo(click_completion.get_code(shell))

    @cli.group(help="Manage agents")
    def agent() -> None:
        pass

    @agent.command("list", help="List agents")
    @click.pass_context
    def agent_list(ctx: click.Context) -> None:
        response = requests.get(urljoin(ctx.obj.server_address, "agents"))
        response.raise_for_status()
        agents = response.json()["agents"]

        if not agents:
            rich.print("No data available")
            return

        rich.print(tabulate(agents, headers="keys"))

    @cli.group(help="Manage sessions")
    def session() -> None:
        pass

    @session.command("new", help="Create a new session")
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=True)
    @click.option("-u", "--end-user-id", type=str, help="End User ID", metavar="ID", required=True)
    @click.pass_context
    def session_new(ctx: click.Context, agent_id: str, end_user_id: str) -> None:
        response = requests.post(
            urljoin(ctx.obj.server_address, "sessions"),
            json={
                "agent_id": agent_id,
                "end_user_id": end_user_id,
            },
        )

        response.raise_for_status()

        print(tabulate([response.json()], headers="keys"))

    @session.command("view", help="View session content")
    @click.argument("session_id")
    @click.pass_context
    def session_view(ctx: click.Context, session_id: str) -> None:
        response = requests.get(urljoin(ctx.obj.server_address, f"sessions/{session_id}/events"))
        response.raise_for_status()
        events: list[dict[str, Any]] = response.json()["events"]

        if not events:
            rich.print("No data available")
            return

        print(
            tabulate(
                [
                    {
                        "id": e["id"],
                        "source": e["source"],
                        "offset": e["offset"],
                        "creation_utc": e["creation_utc"],
                        "message": e["data"]["message"],
                    }
                    for e in events
                ],
                headers="keys",
                maxcolwidths=[None, None, None, None, 40],
            )
        )

    @session.command("post", help="Post user message to session")
    @click.argument("session_id")
    @click.argument("message")
    @click.pass_context
    def session_post(ctx: click.Context, session_id: str, message: str) -> None:
        response = requests.post(
            urljoin(ctx.obj.server_address, f"sessions/{session_id}/events"),
            json={"content": message},
        )

        response.raise_for_status()

        rich.print(tabulate([response.json()], headers="keys"))

    @session.command("chat", help="Enter chat mode within the session")
    @click.argument("session_id")
    @click.pass_context
    def session_chat(ctx: click.Context, session_id: str) -> None:
        def print_message(message_event: dict[str, Any]) -> None:
            role = {"client": "User", "server": "Agent"}.get(m["source"])
            prefix = Text(
                f"{role}:".ljust(6), style="bold " + {"User": "blue", "Agent": "green"}.get(role)
            )

            message = wrap(m["data"]["message"], subsequent_indent=" " * (1 + len(prefix)))

            rich.print(prefix, os.linesep.join(message))

        rich.print(Text("Press CTRL+C at any time to quit\n", style="bold"))

        response = requests.get(urljoin(ctx.obj.server_address, f"sessions/{session_id}/events"))
        response.raise_for_status()

        message_events = [e for e in response.json()["events"] if e["type"] == Event.MESSAGE_TYPE]

        max_number_of_history_events_to_show = 5

        if len(message_events) > max_number_of_history_events_to_show:
            rich.print(
                f"[skipping {len(message_events) - max_number_of_history_events_to_show} "
                "event(s) in history...]\n"
            )
            message_events = message_events[-max_number_of_history_events_to_show:]

        for m in message_events:
            print_message(m)

        while True:
            try:
                rich.print(Text("User:  ", style="bold blue"), end="")
                new_message = input()

                response = requests.post(
                    urljoin(ctx.obj.server_address, f"sessions/{session_id}/events"),
                    json={"content": new_message},
                )
                response.raise_for_status()
                new_event = response.json()

                last_known_offset = new_event["event_offset"]

                while response := requests.get(
                    urljoin(
                        ctx.obj.server_address,
                        f"sessions/{session_id}/events"
                        f"?min_offset={1 + last_known_offset}&wait=true",
                    )
                ):
                    events = response.json()["events"]
                    last_known_offset = events[-1]["offset"]

                    if message_events := [
                        e for e in response.json()["events"] if e["type"] == Event.MESSAGE_TYPE
                    ]:
                        for m in message_events:
                            print_message(m)
                        break

            except KeyboardInterrupt:
                rich.print("\nQuitting...")
                return

    cli()


if __name__ == "__main__":
    asyncio.run(main())
