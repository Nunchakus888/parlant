#!/usr/bin/python3
# mypy: disable-error-code=import-untyped

import asyncio
from dataclasses import dataclass
import os
import sys
import time
from typing import Any, Optional, cast
from urllib.parse import urljoin
import click
import click.shell_completion
import click_completion
import requests
import rich
from rich.text import Text
from tabulate import tabulate
from textwrap import wrap
from tqdm import tqdm


class _CoherenceCheckFailue(Exception):
    def __init__(self, contradictions: list[dict[str, Any]]) -> None:
        self.contradictions = contradictions


class Actions:
    @staticmethod
    def list_agents(ctx: click.Context) -> list[dict[str, Any]]:
        response = requests.get(urljoin(ctx.obj.server_address, "agents"))
        response.raise_for_status()
        return response.json()["agents"]  # type: ignore

    @staticmethod
    def create_session(
        ctx: click.Context,
        agent_id: str,
        end_user_id: str,
        title: Optional[str] = None,
    ) -> dict[str, Any]:
        response = requests.post(
            urljoin(ctx.obj.server_address, "/sessions"),
            json={
                "agent_id": agent_id,
                "end_user_id": end_user_id,
                "title": title,
            },
        )

        response.raise_for_status()

        return response.json()  # type: ignore

    @staticmethod
    def list_events(ctx: click.Context, session_id: str) -> dict[str, Any]:
        response = requests.get(urljoin(ctx.obj.server_address, f"/sessions/{session_id}/events"))
        response.raise_for_status()
        return response.json()["events"]  # type: ignore

    @staticmethod
    def create_event(ctx: click.Context, session_id: str, message: str) -> dict[str, Any]:
        response = requests.post(
            urljoin(ctx.obj.server_address, f"/sessions/{session_id}/events"),
            json={"content": message},
        )

        response.raise_for_status()

        return response.json()  # type: ignore

    @staticmethod
    def add_term(
        ctx: click.Context, agent_id: str, name: str, description: str, synonyms: Optional[str]
    ) -> dict[str, Any]:
        response = requests.post(
            urljoin(ctx.obj.server_address, f"/agents/{agent_id}/terms"),
            json={
                "name": name,
                "description": description,
                **({"synonyms": synonyms.split(",")} if synonyms else {}),
            },
        )
        response.raise_for_status()
        return response.json()  # type: ignore

    @staticmethod
    def remove_term(ctx: click.Context, agent_id: str, name: str) -> dict[str, Any]:
        response = requests.remove(
            urljoin(ctx.obj.server_address, f"/agents/{agent_id}/terms/{name}")
        )
        response.raise_for_status()
        return response.json()  # type: ignore

    @staticmethod
    def list_terms(ctx: click.Context, agent_id: str) -> list[dict[str, Any]]:
        response = requests.get(urljoin(ctx.obj.server_address, f"/agents/{agent_id}/terms"))
        response.raise_for_status()
        return response.json()["terms"]  # type: ignore

    @staticmethod
    def create_guideline(
        ctx: click.Context, agent_id: str, predicate: str, action: str, check: bool, index: bool
    ) -> dict[str, Any]:
        response = requests.post(
            urljoin(ctx.obj.server_address, f"/agents/{agent_id}/index/evaluations"),
            json={
                "payloads": [
                    {
                        "kind": "guideline",
                        "predicate": predicate,
                        "action": action,
                    }
                ],
                "coherence_check": check,
                "connection_proposition": index,
            },
        )
        response.raise_for_status()
        evaluation_id = response.json()["evaluation_id"]

        with tqdm(
            total=100,
            desc="Evaluating guideline impact",
            bar_format="{l_bar}{bar}| {n_fmt}/{total_fmt} [{elapsed}]",
        ) as progress_bar:
            while True:
                time.sleep(0.5)
                response = requests.get(
                    urljoin(ctx.obj.server_address, f"/agents/index/evaluations/{evaluation_id}")
                )
                response.raise_for_status()
                evaluation = response.json()

                if evaluation["status"] in ["pending", "running"]:
                    progress_bar.n = int(evaluation["progress"])
                    progress_bar.refresh()

                    continue

                if evaluation["status"] == "completed":
                    invoice = evaluation["invoices"][0]
                    if invoice["approved"]:
                        progress_bar.n = 100
                        progress_bar.refresh()

                        guideline_response = requests.post(
                            urljoin(ctx.obj.server_address, f"/agents/{agent_id}/guidelines/"),
                            json={
                                "invoices": [invoice],
                            },
                        )
                        guideline_response.raise_for_status()

                        return cast(dict[str, Any], guideline_response.json()["guidelines"][0])

                    else:
                        raise _CoherenceCheckFailue(
                            contradictions=invoice["data"]["coherence_checks"]
                        )

                elif evaluation["status"] == "failed":
                    raise ValueError(evaluation["error"])

    @staticmethod
    def remove_guideline(ctx: click.Context, agent_id: str, guideline_id: str) -> dict[str, Any]:
        response = requests.delete(
            urljoin(ctx.obj.server_address, f"/agents/{agent_id}/guidelines/{guideline_id}")
        )
        response.raise_for_status()
        return response.json()

    @staticmethod
    def get_guideline(ctx: click.Context, agent_id: str, guideline_id: str) -> dict[str, Any]:
        response = requests.get(
            urljoin(ctx.obj.server_address, f"/agents/{agent_id}/guidelines/{guideline_id}")
        )
        response.raise_for_status()
        return response.json()  # type: ignore

    @staticmethod
    def list_guidelines(ctx: click.Context, agent_id: str) -> list[dict[str, Any]]:
        response = requests.get(urljoin(ctx.obj.server_address, f"agents/{agent_id}/guidelines"))
        response.raise_for_status()
        return response.json()["guidelines"]  # type: ignore

    @staticmethod
    def create_connection(
        ctx: click.Context,
        agent_id: str,
        source_guideline_id: str,
        target_guideline_id: str,
        kind: str,
    ) -> dict[str, Any]:
        response = requests.patch(
            urljoin(ctx.obj.server_address, f"/agents/{agent_id}/guidelines/{source_guideline_id}"),
            json={
                "added_connections": [
                    {
                        "source": source_guideline_id,
                        "target": target_guideline_id,
                        "kind": kind,
                    }
                ],
            },
        )
        response.raise_for_status()
        return response.json()  # type: ignore


class Interface:
    @staticmethod
    def list_agents(ctx: click.Context) -> None:
        agents = Actions.list_agents(ctx)

        if not agents:
            rich.print("No data available")
            return

        rich.print(tabulate(agents, headers="keys"))

    @staticmethod
    def get_default_agent(ctx: click.Context) -> str:
        agents = Actions.list_agents(ctx)
        assert agents
        return str(agents[0]["id"])

    @staticmethod
    def view_session(ctx: click.Context, session_id: str) -> None:
        events = Actions.list_events(ctx, session_id)

        if not events:
            rich.print("No data available")
            return

        print(
            tabulate(
                [
                    {
                        "id": e["id"],  # type: ignore
                        "source": e["source"],  # type: ignore
                        "offset": e["offset"],  # type: ignore
                        "creation_utc": e["creation_utc"],  # type: ignore
                        "message": e["data"]["message"],  # type: ignore
                    }
                    for e in events
                ],
                headers="keys",
                maxcolwidths=[None, None, None, None, 40],
            )
        )

    @staticmethod
    def create_session(
        ctx: click.Context,
        agent_id: str,
        end_user_id: str,
        title: Optional[str] = None,
    ) -> None:
        session = Actions.create_session(ctx, agent_id, end_user_id, title)
        print(tabulate([session], headers="keys"))

    @staticmethod
    def create_event(ctx: click.Context, session_id: str, message: str) -> None:
        event = Actions.create_event(ctx, session_id, message)
        rich.print(tabulate([event], headers="keys"))

    @staticmethod
    def chat(ctx: click.Context, session_id: str) -> None:
        def print_message(message_event: dict[str, Any]) -> None:
            role = {"client": "User", "server": "Agent"}[message_event["source"]]
            prefix = Text(
                f"{role}:".ljust(6), style="bold " + {"User": "blue", "Agent": "green"}[role]
            )

            message = wrap(
                message_event["data"]["message"], subsequent_indent=" " * (1 + len(prefix))
            )

            rich.print(prefix, os.linesep.join(message))

        rich.print(Text("Press CTRL+C at any time to quit\n", style="bold"))

        response = requests.get(urljoin(ctx.obj.server_address, f"/sessions/{session_id}/events"))
        response.raise_for_status()

        message_events = [e for e in response.json()["events"] if e["kind"] == "message"]

        max_number_of_history_events_to_show = 5

        if len(message_events) > max_number_of_history_events_to_show:
            rich.print(
                f"(skipping {len(message_events) - max_number_of_history_events_to_show} "
                "event(s) in history...)\n",
                flush=True,
            )
            message_events = message_events[-max_number_of_history_events_to_show:]

        for m in message_events:
            print_message(m)

        last_known_offset = message_events[-1]["offset"] if message_events else -1

        while True:
            try:
                rich.print(Text("User:  ", style="bold blue"), end="")
                new_message = input()

                response = requests.post(
                    urljoin(
                        ctx.obj.server_address,
                        f"/sessions/{session_id}/events",
                    ),
                    json={"content": new_message},
                )
                response.raise_for_status()
                new_event = response.json()

                last_known_offset = new_event["event_offset"]

                while True:
                    response = requests.get(
                        urljoin(
                            ctx.obj.server_address,
                            f"/sessions/{session_id}/events"
                            f"?min_offset={1 + last_known_offset}&wait=true",
                        )
                    )

                    if response.status_code == 504:
                        # Timeout occurred; try again
                        continue

                    events = response.json()["events"]
                    if not events:
                        continue

                    last_known_offset = events[-1]["offset"]

                    message_events = [e for e in events if e["kind"] == "message"]
                    if message_events:
                        for m in message_events:
                            print_message(m)
                        break

            except KeyboardInterrupt:
                rich.print("\nQuitting...", flush=True)
                return

    @staticmethod
    def create_term(
        ctx: click.Context,
        agent_id: str,
        name: str,
        description: str,
        synonyms: Optional[str],
    ) -> None:
        term = Actions.add_term(ctx, agent_id, name, description, synonyms)
        rich.print(tabulate([term], headers="keys"))

    @staticmethod
    def remove_term(ctx: click.Context, agent_id: str, name: str) -> None:
        result = Actions.remove_term(ctx, agent_id, name)
        rich.print(result)

    @staticmethod
    def list_terms(ctx: click.Context, agent_id: str) -> None:
        terms = Actions.list_terms(ctx, agent_id)

        if not terms:
            rich.print("No terms found")
            return

        rich.print(tabulate(terms, headers="keys"))

    @staticmethod
    def create_guideline(
        ctx: click.Context,
        agent_id: str,
        predicate: str,
        action: str,
        check: bool,
        index: bool,
    ) -> None:
        try:
            guideline = Actions.create_guideline(ctx, agent_id, predicate, action, check, index)
            rich.print(Text(f"\nAdded guideline (id={guideline['id']}).\n", style="bold green"))
            rich.print(tabulate([guideline], headers="keys"))
        except _CoherenceCheckFailue as e:
            contradictions = e.contradictions
            rich.print(Text("\nFailed to add guideline.", style="bold red"))
            rich.print("\nDetected incoherence with other guidelines:\n")
            rich.print(
                tabulate(
                    contradictions,
                    headers="keys",
                    maxcolwidths=[20, 20, 20, 40, 10],
                    tablefmt="rounded_grid",
                )
            )
            rich.print(
                Text("\nTo force add despite these errors, re-run with --no-check.", style="bold")
            )
        except Exception as e:
            rich.print(Text(f"error: {type(e)}: {e}", style="bold red"))

    @staticmethod
    def remove_guideline(ctx: click.Context, agent_id: str, guideline_id: str) -> None:
        try:
            guideline = Actions.remove_guideline(ctx, agent_id, guideline_id)
            rich.print(
                f"Guideline with ID '{guideline_id}' has been successfully removed.",
                style="bold green",
            )
            rich.print(tabulate([guideline], headers="keys"))
        except Exception as e:
            rich.print(Text(f"error: {type(e)}: {e}", style="bold red"), file=sys.stderr)

    @staticmethod
    def view_guideline(ctx: click.Context, agent_id: str, guideline_id: str) -> None:
        try:
            guideline = Actions.get_guideline(ctx, agent_id, guideline_id)
            rich.print(tabulate([guideline], headers="keys"))

            if guideline["connections"]:
                rich.print("\nConnections:")
                rich.print(
                    tabulate(
                        [
                            {
                                "id": c["id"],  # type: ignore
                                "source": c["source"],  # type: ignore
                                "target": c["target"],  # type: ignore
                                "connection_kind": c["kind"],  # type: ignore
                            }
                            for c in guideline["connections"]
                        ],
                        headers="keys",
                        maxcolwidths=[None, None, None, None],
                    )
                )
            else:
                rich.print("\nNo connections found for this guideline.")
        except Exception as e:
            rich.print(Text(f"error: {type(e)}: {e}", style="bold red"))

    @staticmethod
    def list_guidelines(ctx: click.Context, agent_id: str) -> None:
        try:
            guidelines = Actions.list_guidelines(ctx, agent_id)
            if not guidelines:
                rich.print(f"No guidelines found for agent {agent_id}.")
                return

            data = [
                {
                    "ID": g["id"],
                    "Predicate": g["predicate"],
                    "Action": g["action"],
                }
                for g in guidelines
            ]

            rich.print(f"Guidelines for Agent ID: {agent_id}")
            rich.print(
                tabulate(
                    data,
                    headers="keys",
                    tablefmt="grid",
                    maxcolwidths=[None, 40, 40],
                )
            )

        except Exception as e:
            rich.print(Text(f"error: {type(e)}: {e}", style="bold red"))

    @staticmethod
    def create_connection(
        ctx: click.Context,
        agent_id: str,
        source_guideline_id: str,
        target_guideline_id: str,
        kind: str,
    ) -> None:
        try:
            connection = Actions.create_connection(
                ctx,
                agent_id,
                source_guideline_id,
                target_guideline_id,
                kind,
            )
            rich.print("Connection created:")
            rich.print(f"{tabulate([connection], headers="keys")}")
        except Exception as e:
            rich.print(Text(f"error: {type(e)}: {e}", style="bold red"))


async def main() -> None:
    click_completion.init()

    @dataclass(frozen=True)
    class Config:
        server_address: str

    @click.group
    @click.option(
        "-s", "--server", type=str, help="Server address", metavar="ADDRESS[:PORT]", required=True
    )
    @click.pass_context
    def cli(ctx: click.Context, server: str) -> None:
        if not ctx.obj:
            ctx.obj = Config(server_address=server)

    @cli.command(help="Generate shell completion code")
    @click.option("-s", "--shell", type=str, help="Shell program (bash, zsh, etc.)", required=True)
    def complete(shell: str) -> None:
        click.echo(click_completion.get_code(shell))

    @cli.group(help="Manage agents")
    def agent() -> None:
        pass

    @agent.command("list", help="List agents")
    @click.pass_context
    def agent_list(ctx: click.Context) -> None:
        Interface.list_agents(ctx)

    @agent.command(
        "chat",
        help="Jump into a chat with an agent\n\n"
        "If AGENT_ID is omitted, the default agent will be selected.",
    )
    @click.argument("agent_id", required=False)
    @click.pass_context
    def agent_chat(ctx: click.Context, agent_id: Optional[str]) -> None:
        agent_id = agent_id if agent_id else Interface.get_default_agent(ctx)
        assert agent_id

        session = Actions.create_session(ctx, agent_id=agent_id, end_user_id="<unused>")

        Interface.chat(ctx, session["id"])

    @cli.group(help="Manage sessions")
    def session() -> None:
        pass

    @session.command("new", help="Create a new session")
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=False)
    @click.option("-u", "--end-user-id", type=str, help="End User ID", metavar="ID", required=True)
    @click.option("-t", "--title", type=str, help="Session Title", metavar="TITLE", required=False)
    @click.pass_context
    def session_new(
        ctx: click.Context,
        agent_id: str,
        end_user_id: str,
        title: Optional[str],
    ) -> None:
        agent_id = agent_id if agent_id else Interface.get_default_agent(ctx)
        assert agent_id

        Interface.create_session(ctx, agent_id, end_user_id, title)

    @session.command("view", help="View session content")
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=False)
    @click.argument("session_id")
    @click.pass_context
    def session_view(ctx: click.Context, agent_id: str, session_id: str) -> None:
        agent_id = agent_id if agent_id else Interface.get_default_agent(ctx)
        assert agent_id

        Interface.view_session(ctx, session_id)

    @session.command("post", help="Post user message to session")
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=False)
    @click.argument("session_id")
    @click.argument("message")
    @click.pass_context
    def session_post(ctx: click.Context, agent_id: str, session_id: str, message: str) -> None:
        agent_id = agent_id if agent_id else Interface.get_default_agent(ctx)
        assert agent_id

        Interface.create_event(ctx, session_id, message)

    @session.command("chat", help="Enter chat mode within the session")
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=False)
    @click.argument("session_id")
    @click.pass_context
    def session_chat(ctx: click.Context, agent_id: str, session_id: str) -> None:
        agent_id = agent_id if agent_id else Interface.get_default_agent(ctx)
        assert agent_id

        Interface.chat(ctx, session_id)

    @cli.group(help="Manage Terminology")
    def terminology() -> None:
        pass

    @terminology.command("add", help="Add a new term to the terminology")
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=False)
    @click.option("-n", "--name", type=str, help="Name of the term", required=True)
    @click.option("-d", "--description", type=str, help="Description of the term", required=True)
    @click.option(
        "-s", "--synonyms", type=str, help="Comma-separated list of synonyms", required=False
    )
    @click.pass_context
    def terminology_add(
        ctx: click.Context,
        agent_id: str,
        name: str,
        description: str,
        synonyms: Optional[str],
    ) -> None:
        agent_id = agent_id if agent_id else Interface.get_default_agent(ctx)
        assert agent_id

        Interface.create_term(ctx, agent_id, name, description, synonyms)

    @terminology.command("remove", help="remove a term from the terminology")
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=False)
    @click.option("-n", "--name", type=str, help="Name of the term to remove", required=True)
    @click.pass_context
    def terminology_remove(
        ctx: click.Context,
        agent_id: str,
        name: str,
    ) -> None:
        agent_id = agent_id if agent_id else Interface.get_default_agent(ctx)
        assert agent_id

        Interface.remove_term(ctx, agent_id, name)

    @terminology.command("list", help="List all terms in the terminology")
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=False)
    @click.pass_context
    def terminology_list(
        ctx: click.Context,
        agent_id: str,
    ) -> None:
        agent_id = agent_id if agent_id else Interface.get_default_agent(ctx)
        assert agent_id

        Interface.list_terms(ctx, agent_id)

    @cli.group(help="Manage Guidelines")
    def guideline() -> None:
        pass

    @guideline.command("add", help="Add a new guideline")
    @click.option(
        "--check/--no-check",
        type=bool,
        show_default=True,
        default=True,
        help="Check for contradictions between existing guidelines",
    )
    @click.option(
        "--index/--no-index",
        type=bool,
        show_default=True,
        default=True,
        help="Determine if guideline connections should be indexed",
    )
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=False)
    @click.argument("predicate", type=str)
    @click.argument("action", type=str)
    @click.pass_context
    def guideline_add(
        ctx: click.Context,
        agent_id: str,
        predicate: str,
        action: str,
        check: bool,
        index: bool,
    ) -> None:
        agent_id = agent_id if agent_id else Interface.get_default_agent(ctx)
        assert agent_id

        Interface.create_guideline(
            ctx=ctx,
            agent_id=agent_id,
            predicate=predicate,
            action=action,
            check=check,
            index=index,
        )

    @guideline.command("remove", help="Remove a guideline")
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=False)
    @click.argument("guideline_id", type=str)
    @click.pass_context
    def guideline_remove(
        ctx: click.Context,
        agent_id: str,
        guideline_id: str,
    ) -> None:
        agent_id = agent_id if agent_id else Interface.get_default_agent(ctx)
        assert agent_id

        Interface.remove_guideline(
            ctx=ctx,
            agent_id=agent_id,
            guideline_id=guideline_id,
        )

    @guideline.command("view", help="View a guideline and its connections")
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=False)
    @click.argument("guideline_id", type=str)
    @click.pass_context
    def guideline_view(
        ctx: click.Context,
        agent_id: str,
        guideline_id: str,
    ) -> None:
        agent_id = agent_id if agent_id else Interface.get_default_agent(ctx)
        assert agent_id

        Interface.view_guideline(
            ctx=ctx,
            agent_id=agent_id,
            guideline_id=guideline_id,
        )

    @guideline.command("list", help="List all guidelines for an agent")
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=False)
    @click.pass_context
    def guideline_list(
        ctx: click.Context,
        agent_id: str,
    ) -> None:
        agent_id = agent_id if agent_id else Interface.get_default_agent(ctx)
        assert agent_id

        Interface.list_guidelines(
            ctx=ctx,
            agent_id=agent_id,
        )

    @guideline.command("connect", help="Create a connection between two guidelines")
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=False)
    @click.option(
        "-k", "--kind", type=str, help="Connection kind (entails, suggests)", required=True
    )
    @click.argument("source_guideline_id", type=str)
    @click.argument("target_guideline_id", type=str)
    @click.pass_context
    def guideline_connect(
        ctx: click.Context,
        agent_id: str,
        kind: str,
        source_guideline_id: str,
        target_guideline_id: str,
    ) -> None:
        agent_id = agent_id if agent_id else Interface.get_default_agent(ctx)
        assert agent_id

        Interface.create_connection(
            ctx=ctx,
            agent_id=agent_id,
            source_guideline_id=source_guideline_id,
            target_guideline_id=target_guideline_id,
            kind=kind,
        )

    cli()


if __name__ == "__main__":
    asyncio.run(main())
