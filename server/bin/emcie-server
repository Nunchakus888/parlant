#!/usr/bin/python3

import asyncio
from contextlib import asynccontextmanager
from dataclasses import dataclass
from datetime import datetime, timezone
import os
from fastapi import FastAPI
from lagom import Container
from typing import Any, AsyncIterator
import click
import click_completion
import json
from pathlib import Path
import sys
import rich
from rich.text import Text
from tabulate import tabulate
import uvicorn

from emcie.server.api.app import create_app
from emcie.server.core.agents import AgentDocumentStore, AgentStore
from emcie.server.core.context_variables import ContextVariableDocumentStore, ContextVariableStore
from emcie.server.core.end_users import EndUserDocumentStore, EndUserStore
from emcie.server.core.guidelines import (
    Guideline,
    GuidelineDocumentStore,
    GuidelineId,
    GuidelineStore,
)
from emcie.server.core.persistence import JSONFileDocumentDatabase
from emcie.server.core.sessions import (
    PollingSessionListener,
    SessionDocumentStore,
    SessionListener,
    SessionStore,
)
from emcie.server.core.tools import ToolDocumentStore, ToolStore
from emcie.server.engines.alpha.coherence_checker import CoherenceChecker
from emcie.server.engines.alpha.engine import AlphaEngine
from emcie.server.engines.alpha.guideline_tool_associations import (
    GuidelineToolAssociationDocumentStore,
    GuidelineToolAssociationStore,
)
from emcie.server.engines.common import Engine
from emcie.server.mc import MC

DEFAULT_PORT = 8000

SERVER_HOME_DIR = Path(os.environ.get("EMCIE_HOME", "/var/lib/emcie"))
SERVER_HOME_DIR.mkdir(parents=True, exist_ok=True)

TOOL_NAME_TO_ID: dict[str, str] = {}


sys.path.append(SERVER_HOME_DIR.as_posix())


@dataclass
class CLIParams:
    config: dict[str, Any]
    port: int


async def load_agents(c: Container, config: Any) -> None:
    store = c[AgentStore]
    existing_agents = await store.list_agents()

    for agent_name in config["agents"]:
        if not [a for a in existing_agents if a.name == agent_name]:
            await store.create_agent(name=agent_name)


async def load_tools(c: Container, config: Any) -> None:
    tool_store = c[ToolStore]

    for tool_name, tool in config["tools"].items():
        tool = await tool_store.create_tool(
            name=tool["function_name"],
            module_path=tool["module_path"],
            description=tool["description"],
            parameters=tool["parameters"],
            required=tool["required"],
            consequential=False,
        )

        TOOL_NAME_TO_ID[tool_name] = tool.id


async def load_guidelines(c: Container, config: Any) -> None:
    agent_store = c[AgentStore]
    guideline_store = c[GuidelineStore]
    guideline_tool_association_store = c[GuidelineToolAssociationStore]

    agents = await agent_store.list_agents()

    for agent_name, guidelines in config["guidelines"].items():
        agent_id = next(a.id for a in agents if a.name == agent_name)

        for guideline_spec in guidelines:
            guideline = await guideline_store.create_guideline(
                guideline_set=agent_id,
                predicate=guideline_spec["when"],
                content=guideline_spec["then"],
            )

            for tool_name in guideline_spec.get("enabled_tools", []):
                await guideline_tool_association_store.create_association(
                    guideline_id=guideline.id,
                    tool_id=TOOL_NAME_TO_ID[tool_name],
                )


@asynccontextmanager
async def setup_container(config: Any) -> AsyncIterator[Container]:
    for store_name in "guidelines", "tools", "guideline_tool_associations", "context_variables":
        (SERVER_HOME_DIR / f"{store_name}.json").unlink(missing_ok=True)

    c = Container()

    c[AgentStore] = AgentDocumentStore(JSONFileDocumentDatabase(SERVER_HOME_DIR / "agents.json"))
    c[ContextVariableStore] = ContextVariableDocumentStore(
        JSONFileDocumentDatabase(SERVER_HOME_DIR / "context_variables.json")
    )
    c[EndUserStore] = EndUserDocumentStore(
        JSONFileDocumentDatabase(SERVER_HOME_DIR / "end_users.json")
    )
    c[GuidelineStore] = GuidelineDocumentStore(
        JSONFileDocumentDatabase(SERVER_HOME_DIR / "guidelines.json")
    )
    c[GuidelineToolAssociationStore] = GuidelineToolAssociationDocumentStore(
        JSONFileDocumentDatabase(SERVER_HOME_DIR / "guideline_tool_associations.json")
    )
    c[SessionStore] = SessionDocumentStore(
        JSONFileDocumentDatabase(SERVER_HOME_DIR / "sessions.json")
    )
    c[ToolStore] = ToolDocumentStore(JSONFileDocumentDatabase(SERVER_HOME_DIR / "tools.json"))
    c[SessionListener] = PollingSessionListener
    c[Engine] = AlphaEngine

    for loader in load_agents, load_tools, load_guidelines:
        await loader(c, config)

    async with MC(c) as mc:
        c[MC] = mc
        yield c


@asynccontextmanager
async def load_app(config: Any) -> AsyncIterator[FastAPI]:
    async with setup_container(config) as container:
        yield await create_app(container)


async def serve_app(app: FastAPI, port: int) -> None:
    config = uvicorn.Config(app, host="0.0.0.0", port=port, log_level="info")
    server = uvicorn.Server(config)
    await server.serve()


async def start_server(params: CLIParams) -> None:
    async with load_app(params.config) as app:
        try:
            await serve_app(app, params.port)
        except KeyboardInterrupt:
            pass


async def check_coherence(params: CLIParams) -> None:
    def render_guideline(g: Guideline) -> str:
        return f"When {g.predicate}, then {g.content}"

    checker = CoherenceChecker()

    for agent, guideline_specs in params.config["guidelines"].items():
        guidelines = [
            Guideline(
                id=GuidelineId(str(index)),
                creation_utc=datetime.now(timezone.utc),
                predicate=guideline["when"],
                content=guideline["then"],
            )
            for index, guideline in enumerate(guideline_specs)
        ]

        guidelines_by_id = {g.id: g for g in guidelines}

        tests = [
            t
            for t in await checker.evaluate_coherence(
                proposed_guidelines=guidelines,
                existing_guidelines=[],
            )
            if t.severity >= 6
        ]

        if tests:
            rich.print(Text(f'{len(tests)} issues found in "{agent}"\n', style="bold red"))
            entries = [
                {
                    "existing": render_guideline(guidelines_by_id[t.existing_guideline_id]),
                    "proposed": render_guideline(guidelines_by_id[t.proposed_guideline_id]),
                    "issue": t.rationale,
                    "severity": t.severity,
                }
                for t in tests
            ]
            rich.print(
                tabulate(
                    entries,
                    headers="keys",
                    maxcolwidths=[20, 20, 40, 10],
                    tablefmt="rounded_grid",
                )
            )
            rich.print()


if __name__ == "__main__":
    click_completion.init()

    @click.group
    @click.option(
        "-c",
        "--config-file",
        type=str,
        help="Server configuration file",
        metavar="FILE",
        required=True,
        default=SERVER_HOME_DIR / "config.json",
    )
    @click.pass_context
    def cli(ctx: click.Context, config_file: str) -> None:
        if not ctx.obj:
            config_file_path = Path(config_file)

            if not config_file_path.exists():
                print(f"error: config file not found: {config_file_path}", file=sys.stderr)
                exit(1)

            with open(config_file_path, "r") as config_file:
                config = json.load(config_file)

                ctx.obj = CLIParams(
                    config=config,
                    port=DEFAULT_PORT,
                )

    @cli.command(help="Run the Emcie server")
    @click.option(
        "-p",
        "--port",
        type=int,
        default=DEFAULT_PORT,
        help="Server port",
    )
    @click.pass_context
    def run(ctx: click.Context, port: int) -> None:
        ctx.obj.port = port
        asyncio.run(start_server(ctx.obj))

    @cli.command(help="Check the configuration's validity and coherence")
    @click.pass_context
    def check(ctx: click.Context) -> None:
        asyncio.run(check_coherence(ctx.obj))

    cli()
